package cmd

import (
	"errors"
	"fmt"
	"os/exec"
	"sort"
	"strings"

	"github.com/AlecAivazis/survey/v2"
	"github.com/hashicorp/go-getter"
	"github.com/sirupsen/logrus"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
)

type DirectoryLayoutType int

const (
	Simple DirectoryLayoutType = iota
	Tracks
	UnknownDirectoryLayoutType
)

func stringToDirectoryLayoutType(s string) (DirectoryLayoutType, error) {
	if s == "simple" {
		return Simple, nil
	} else if s == "tracks" {
		return Tracks, nil
	}

	return UnknownDirectoryLayoutType, errors.New("Invalid layout type")
}

type ToolType int

const (
	AzureCLIToolType ToolType = iota
	GCloudToolType
	UnknownToolType
)

func stringToToolType(s string) (ToolType, error) {
	if s == "azure-cli" {
		return AzureCLIToolType, nil
	} else if s == "gcloud" {
		return GCloudToolType, nil
	}

	return UnknownToolType, errors.New("Invalid tool type")
}

type ScmType int

const (
	None ScmType = iota
	Git
	UnknownScmType
)

func stringToScmType(s string) (ScmType, error) {
	if s == "none" {
		return None, nil
	} else if s == "git" {
		return Git, nil
	}

	return UnknownScmType, errors.New("Invalid SCM type")
}

type RunnerType int

const (
	UnknownRunner RunnerType = iota
	ArmRunnerType
	TerraformRunnerType
)

func stringToRunner(s string) (RunnerType, error) {
	if s == "arm" {
		return ArmRunnerType, nil
	} else if s == "terraform" {
		return TerraformRunnerType, nil
	}

	return UnknownRunner, errors.New("Invalid runner type")
}

const gitIgnore = `# Generated by runiac CLI.
.DS_Store
.runiac
`

const entrypointScript = `# Generated by runiac CLI.
runiac
`

const runiacConfig = `# Generated by runiac CLI.
project: ${PROJECT_NAME}
primary_region: ${PRIMARY_REGION}
regional_regions: ${PRIMARY_REGION}
runner: ${RUNNER}
`

func init() {
	rootCmd.AddCommand(newCmd)
}

func createSimpleDirectories(name string, fs afero.Fs) error {
	err := fs.MkdirAll(fmt.Sprintf("%s/step1_initial", name), 0755)
	if err != nil {
		return err
	}

	return nil
}

func createTracksDirectories(name string, fs afero.Fs) error {
	err := fs.MkdirAll(fmt.Sprintf("%s/tracks/initial/step1_initial", name), 0755)
	if err != nil {
		return err
	}

	return nil
}

func checkForGit() (err error) {
	// check if git is available
	_, err = exec.LookPath("git")
	return
}

func discoverScms() (scmTypes []ScmType) {
	scmTypes = make([]ScmType, 0)

	err := checkForGit()
	if err == nil {
		scmTypes = append(scmTypes, Git)
	}

	return
}

func initializeGit(name string, fs afero.Fs) error {
	err := checkForGit()
	if err != nil {
		return err
	}

	// initialize the repository
	cmd := exec.Command("git", "init")
	cmd.Dir = name
	_, err = cmd.Output()
	if err != nil {
		return err
	}

	// create a default .gitignore
	err = afero.WriteFile(fs, fmt.Sprintf("%s/.gitignore", name), []byte(gitIgnore), 0644)
	if err != nil {
		return err
	}

	return nil
}

func initializeRuniacConfig(projectName string, region string, runner string, fs afero.Fs) (err error) {
	runiacConfigYml := strings.ReplaceAll(runiacConfig, "${PROJECT_NAME}", projectName)
	runiacConfigYml = strings.ReplaceAll(runiacConfigYml, "${PRIMARY_REGION}", region)
	runiacConfigYml = strings.ReplaceAll(runiacConfigYml, "${RUNNER}", runner)

	err = afero.WriteFile(fs, fmt.Sprintf("%s/runiac.yml", projectName), []byte(runiacConfigYml), 0644)
	if err != nil {
		return err
	}

	return
}

func initializeFiles(projectName string, fs afero.Fs) (err error) {
	err = afero.WriteFile(fs, fmt.Sprintf("%s/entrypoint.sh", projectName), []byte(entrypointScript), 0744)
	if err != nil {
		return err
	}

	return
}

func initializeProject(projectName string, baseContainer string) error {
	// initialize runiac in the new directory
	err := InitializeDirectory(projectName, baseContainer)
	if err != nil {
		logrus.Warn(fmt.Sprintf("Initialized a new project in directory %s, but 'runiac init' failed. Try running it manually.", projectName))
		return err
	}

	fmt.Printf("üç∫ Initialized a new project in directory: %s.\n", projectName)
	return nil
}

func initializeScm(projectName string, scm ScmType, fs afero.Fs) error {
	switch scm {
	case Git:
		return initializeGit(projectName, fs)
	}

	return nil
}

func process() error {
	// ask for project name and validate that a directory with that name doesn't already exist
	name := ""
	err := survey.AskOne(&survey.Input{
		Message: "Choose a name for your project:",
	}, &name, survey.WithValidator(func(val interface{}) error {
		str, ok := val.(string)
		if !ok {
			return errors.New("Invalid directory. Choose a different project name.")
		}

		// check if directory already exists
		exists, _ := afero.DirExists(afero.NewOsFs(), str)
		if exists {
			return errors.New(fmt.Sprintf("A directory '%s' already exists or is not valid. Choose a different project name.", str))
		}

		return nil
	}))

	if err != nil {
		return err
	}

	// ask for project template
	template := ""
	err = survey.AskOne(&survey.Select{
		Message: "What type of project do you want to create?",
		Options: []string{
			"azure-arm - Use ARM templates for Microsoft Azure",
			"azure-terraform - Use Terraform for Microsoft Azure",
			"gcp-terraform - Use Terraform for Google Cloud Platform",
			"kitchen-sink - Use Terraform across various cloud providers and services",
			"third-party - Download a third-party template from a URL",
			"custom - Configure a custom project not based on a specific template",
		},
		Help: `A template provides standard directory structures as recommended by runiac developers. You can always migrate from one
type of project to another by rearranging your directories manually after the fact.`,
	}, &template, survey.WithValidator(survey.Required))

	if err != nil {
		return err
	}

	projectTemplate := strings.TrimSpace(strings.Split(template, " - ")[0])
	if projectTemplate == "third-party" {
		return processThirdParty(name)
	} else if projectTemplate == "custom" {
		return processCustom(name)
	} else {
		return processPredefined(name, projectTemplate)
	}

	return nil
}

func promptForSourceControl() (ScmType, error) {
	scmTypes := discoverScms()
	scmOptions := make([]string, 0)
	for _, scmType := range scmTypes {
		switch scmType {
		case Git:
			scmOptions = append(scmOptions, "git - Initialize a git repository in the project directory")
		}
	}

	scmOptions = append(scmOptions, "none - do not use any source control tool")

	scmTypeValue := ""
	err := survey.AskOne(&survey.Select{
		Message: "Which source control tool do you want to use?",
		Options: scmOptions,
	}, &scmTypeValue, survey.WithValidator(survey.Required))

	if err != nil {
		return UnknownScmType, err
	}

	scmType := strings.TrimSpace(strings.Split(scmTypeValue, " - ")[0])

	// validate scm type
	scm, err := stringToScmType(scmType)
	if err != nil {
		logrus.Error(fmt.Sprintf("Unknown SCM type '%s' (valid types: none, git)", scmType))
		return UnknownScmType, err
	}

	return scm, nil
}

func promptForConfirmation() (bool, error) {
	prompt := &survey.Confirm{
		Message: "Does everything look good?",
	}

	confirm := false
	err := survey.AskOne(prompt, &confirm)
	if err != nil {
		return false, nil
	}

	return confirm, nil
}

func processThirdParty(name string) error {
	source := ""
	err := survey.AskOne(&survey.Input{
		Message: "What is the URL for the template?",
		Help: `This is the URL where the project template is hosted. It must be accessible from your current network, and must not 
require authentication. 

When using GitHub:
You can provide a shorthand form, such as github.com/user/runiac-template instead. For subdirectories, use a double slash
to indicate the path under the GitHub repository: github.com/user/runiac-template//simple-variant.`,
	}, &source, survey.WithValidator(survey.Required))

	if err != nil {
		return err
	}

	scm, err := promptForSourceControl()
	if err != nil {
		return err
	}

	err = getter.Get(name, source)
	if err != nil {
		return err
	}

	if scm != None {
		err = initializeScm(name, scm, afero.NewOsFs())
		if err != nil {
			return err
		}
	}

	err = initializeProject(name, DefaultBaseContainer)
	if err != nil {
		logrus.WithError(err).Error(err)
	}

	return nil
}

func processPredefined(name string, template string) error {
	scm, err := promptForSourceControl()
	if err != nil {
		return err
	}

	subdir := ""
	containerTag := ""
	switch template {
	case "azure-arm":
		subdir = "arm-azure-hello-world"
		containerTag = "azure"
	case "azure-terraform":
		subdir = "terraform-azure-hello-world"
		containerTag = "azure"
	case "gcp-terraform":
		subdir = "terraform-gcp-hello-world"
		containerTag = "gcloud"
	case "kitchen-sink":
		subdir = "kitchen-sink"
		containerTag = "azure-gcloud"
	}

	source := fmt.Sprintf("github.com/optum/runiac.git//examples/%s", subdir)
	err = getter.Get(name, source)
	if err != nil {
		return err
	}

	if scm != None {
		err = initializeScm(name, scm, afero.NewOsFs())
		if err != nil {
			return err
		}
	}

	err = initializeProject(name, fmt.Sprintf("%s-%s", DefaultBaseContainer, containerTag))
	if err != nil {
		logrus.WithError(err).Error(err)
	}

	return nil
}

func processCustom(name string) error {
	questions := []*survey.Question{
		{
			Name: "layout",
			Prompt: &survey.Select{
				Message: "How do you want to organize your infrastructure deployment? (simple, tracks)",
				Options: []string{
					"simple - A single set of steps",
					"tracks - Multiple groups of steps that can be executed in parallel",
				},
				Help: `You can choose to organize your infrastructure deployment strategy into a single set of steps or into a more complex 
grouping of steps that can be executed in parallel.`,
			},
		},
		{
			Name: "primaryRegion",
			Prompt: &survey.Input{
				Message: "Which cloud provider region will your resources primarily be deployed to? (us-central1, southcentralus, etc.)",
				Help: `Depending on which cloud service(s) you intend to deploy to, this value will be the name of a region. For example, when deploying
to Microsoft Azure, valid regions include 'southcentralus' and 'eastus2'. When deploying to Google Cloud Platform, then the region
name could be 'us-central1'.`,
			},
		},
		{
			Name: "runner",
			Prompt: &survey.Select{
				Message: "Which deployment tool do you want to use?",
				Options: []string{
					"arm - Use Azure Resource Manager templates (preview)",
					"terraform - Use Hashicorp Terraform",
				},
				Help: `runiac will invoke an underlying delivery tool to actually deploy your infrastructure. Currently, ARM templates and Terraform
are supported.`,
			},
		},
		{
			Name: "tools",
			Prompt: &survey.MultiSelect{
				Message: "Choose the set of tools you need to deploy your infrastructure:",
				Options: []string{
					"azure-cli - Microsoft Azure CLI",
					"gcloud - Google Cloud SDK",
				},
				Help: `Your infrastructure may require extra tooling apart from the underlying delivery tool. runiac providers some standard cloud
tools to facilitate this. You may choose zero or many tools to include in your project.`,
			},
		},
	}

	answers := struct {
		Layout        string
		PrimaryRegion string
		Runner        string
		Tools         []string
	}{}

	err := survey.Ask(questions, &answers)
	if err != nil {
		return err
	}

	scm, err := promptForSourceControl()
	if err != nil {
		return err
	}

	layout, err := stringToDirectoryLayoutType(strings.TrimSpace(strings.Split(answers.Layout, " - ")[0]))
	if err != nil {
		return err
	}

	region := answers.PrimaryRegion
	runner := strings.TrimSpace(strings.Split(answers.Runner, " - ")[0])

	confirm, err := promptForConfirmation()
	if !confirm || err != nil {
		err = errors.New("")
		return err
	}

	// validate container tools
	containerTools := make([]ToolType, 0)
	for _, toolTypeValue := range answers.Tools {
		toolType := strings.TrimSpace(strings.Split(toolTypeValue, " - ")[0])

		if toolType == "azure-cli" {
			containerTools = append(containerTools, AzureCLIToolType)
		} else if toolType == "gcloud" {
			containerTools = append(containerTools, GCloudToolType)
		} else if toolType != "" {
			return errors.New(fmt.Sprintf("Unknown tool type '%s' (valid types: azure, gcloud)", toolType))
		}
	}

	fs := afero.NewOsFs()

	// create the project directory
	err = fs.Mkdir(name, 0755)
	if err != nil {
		logrus.WithError(err).Error(err)
		return errors.New("")
	}

	// initialize default files
	err = initializeFiles(name, fs)
	if err != nil {
		logrus.WithError(err).Error(err)
		return errors.New("")
	}

	// create directory structures
	switch layout {
	case Simple:
		err = createSimpleDirectories(name, fs)
		if err != nil {
			logrus.WithError(err).Error(err)
			return errors.New("")
		}

		break

	case Tracks:
		err = createTracksDirectories(name, fs)
		if err != nil {
			logrus.WithError(err).Error(err)
			return errors.New("")
		}

		break
	}

	// determine which base container image to use by default
	// this is somewhat "hacky" since we rely on an implicit naming convention, but for
	// now it can suffice due to us only supporting a few standard image tags
	tags := make([]string, 0)
	for _, containerTool := range containerTools {
		switch containerTool {
		case AzureCLIToolType:
			tags = append(tags, "azure")
		case GCloudToolType:
			tags = append(tags, "gcloud")
		default:
			break
		}
	}

	sort.Strings(tags)
	tags = append([]string{DefaultBaseContainer}, tags...)
	baseContainer := strings.Join(tags, "-")

	// initialize the runiac config file
	err = initializeRuniacConfig(name, region, runner, fs)
	if err != nil {
		logrus.WithError(err).Error(err)
		return err
	}

	// initialize scm repositories
	err = initializeScm(name, scm, fs)
	if err != nil {
		logrus.WithError(err).Error(err)
		return err
	}

	err = initializeProject(name, baseContainer)
	if err != nil {
		logrus.WithError(err).Error(err)
	}

	return nil
}

var newCmd = &cobra.Command{
	Use:   "new [project-name]",
	Short: "Create a new runiac project",
	Long:  `Creates scaffolding for a new runiac project`,
	Args:  cobra.MinimumNArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		err := process()
		if err != nil {
			logrus.Error(fmt.Sprintf("Did not create a new project: %s", err))
			return
		}
	},
}
